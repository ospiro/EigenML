import numpy as np
from numpy import matlib
import pandas as pd
from itertools import product
feature_params = np.genfromtxt("/Users/Oliver/Downloads/Assignment2/model/feature-params.txt",delimiter = ' ')
transition_params = np.genfromtxt("/Users/Oliver/Downloads/Assignment2/model/transition-params.txt",delimiter = ' ')
train = np.genfromtxt("/Users/Oliver/Downloads/Assignment2/data/test_img2.txt",delimiter = ' ')

def logsumexp(arr):
    #logsumexp with shift to avoid overflow
    return np.log(np.sum(np.exp(arr-np.max(arr))))+np.max(arr)

# class CRF():
#     def __init__(self,data):

class potential():
    def __init__(self, deps, type):
        self.deps = deps
        self.type = type

    def _node_potential(self):
        pot=[]
        for i in range(10):
            pot.append(np.sum(feature_params[i,:]*self.deps[0].val))
        return pot
    def _label_edge_potential(self,cn):
        return transition_params[cn,:]
    # def _feature_edge_potential(self,fn,cn):
    #     return self._node_potential()[cn]

    def eval(self, y= None, y1=None, y2=None):
        if self.type=='node':
            return self._node_potential()[y]
        # elif (self.type == 'node' or self.type=='msg') and not y==None:
        #     return self._feature_edge_potential(f,y)
        elif self.type == 'edge' and y2==None:
            return self._label_edge_potential(y1)
        else:
            return self._label_edge_potential(y1)[y2]

#
# def potential(x=None,y=None, s=None,t=None):
#     if y == None and x!= None and s == None and t == None:
#         pot = []
#         for i in range(10):
#             pot.append(np.sum(feature_params[i,:]*x.val))
#         return pot
#     elif y!= None and x != None and s == None and t == None:
#         pot = []
#         for i in range(10):
#             pot.append(np.sum(feature_params[i, :] * x.val))
#         return pot[y.val]
#     elif y== None and x == None and (s != None ^ t != None):
#         n = s.val if s!=None else t.val
#         return transition_params[n]
#     elif y== None and x == None and s != None and t != None:
#         return transition_params[s.val,t.val]

class message():
    def __init__(self,src,dest, tbl):
        self.src = src
        self.dest = dest
        self.tbl = tbl
        self.deps = [dest]
        self.type = 'msg'
    def eval(self,y):
        return self.tbl[y]
    # def eval(self, x, y):
    #     return tbl[x,y]



def compute_msg_update_list(src,dest, active_list, features):
    # dependents = [p for p in active_list if (src in p.deps and (p.type == 'node' or p.type=='msg'))\
    #                     or (src in p.deps and dest in p.deps and p.type == 'edge') ]
    dependents = [p for p in active_list if src in p.deps]
    # dependents = [p for p in active_list if src in deps['p']]
    cond_active_list_node = [p.eval for p in dependents if p.type=='node']
    cond_active_list_edge = [p.eval for p in dependents if p.type == 'edge']
    cond_active_list_msg = [p.eval for p in dependents if p.type == 'msg']

    def sum_arr(val):
        summing_arr = np.array([matlib.repmat(pot(val),1,10) for pot in cond_active_list_node])
        if cond_active_list_msg:
            summing_arr+=np.array([matlib.repmat(pot(val),1,10) for pot in cond_active_list_msg])
            # print("ASDFASDFASDF")

        # print([pot[val] for pot in cond_active_list_msg])
        if cond_active_list_edge:
            summing_arr+=np.array([pot(y1 = val) for pot in cond_active_list_edge])
            # print("asdfasdf")
        return np.exp(summing_arr[0][0])

    _sum = np.zeros(10)
    for i in range(10):
        _sum+=sum_arr(i)
    _sum = np.log(_sum)

    msg = message(src=src, dest=dest, tbl=_sum)

    b = active_list.copy()
    for a in b:
        if a in dependents:
            active_list.remove(a)
    # active_list = [p for p in active_list if p not in dependents]
    active_list.append(msg)
    return msg

class node():
    def __init__(self,type,index, val=None):
        assert type == 'feature' or type == 'label'
        self.type = type
        self.index = index
        self.val = val

# class MRF():
#     def __init__(self, nodes):
#         self.nodes = nodes



# if __name__ == "__main__":
#    #etainoshrd
#    alph = {0:'e',1:'t',2:'a',3:'i',4:'n',5:'o',6:'s',7:'h',8:'r',9:'d'}
#    # for i in range(10):
#    #     print("Compatibility with ",alph[i],": ",feature_potential(train[0,:],i))
#    # print(feature_potential(train,0))
#    blah = np.zeros([train.shape[0],10])
#    for row in range(train.shape[0]):
#        blah[row,:] = feature_potential(train[row,:])
#        print(blah[row,:])
#    # print(blah)
# feature_nodes = [:train.shape[0]]
# label_nodes = [:train.shape[0]]
#
# y_potent = [potential(type = 'edge', deps = [feature_nodes[i],label_nodes[i]]) for i in range(len(train.shape[0]))]
# y_potent += [potential(type='edge',deps = [label_nodes[i],label_nodes[i+1]]) for i in range(len(train.shape[0]-1))]
# x_potent = [potential(deps = [x], type = 'node') for x in feature_nodes]
# active_list = x_potent + y_potent
#skeleton
    # compute_msg_update_list()

#     y1 = node(type = 'label', index =1, val=train[0,:])
#     y2 = node(type = 'label', index =2,val=train[1,:])
#     y3 = node(type = 'label', index =3,val=train[2,:])
#     y4 = node(type = 'label', index =4,val=train[3,:])
#     #
#     pf1 = potential(type='node',deps = [y1])
#     pf2 = potential(type='node',deps = [y2])
#     pf3 = potential(type='node',deps = [y3])
#     pf4 = potential(type='node',deps = [y4])
#     pf12 = potential(type='edge',deps = [y1,y2])
#     pf23 = potential(type='edge',deps = [y2,y3])
#     pf34 = potential(type='edge',deps = [y3,y4])
#
#
# active = [pf1,pf2,pf3,pf4,pf12,pf23,pf34]
#     y = []
#     active = []
#     for i in range(train.shape[0]):
#         y.append(node(type = 'label', index =i, val=train[i,:]))
#         active.append(potential(type='node',deps = [y[i]]))
#     for i in range(train.shape[0]-1):
#         active.append(potential(type='edge',deps = [y[i],y[i+1]]))




def compute_unnorm_marg(t, value, word,active,y):
    a = active.copy()

    #forward messages
    for i in range(t.index):
        compute_msg_update_list(y[i],y[i+1],a,word)
    #backward messages
    for i in range(word.shape[0]-1,t.index,-1):
        compute_msg_update_list(y[i], y[i-1], a, word)
    _sum = 0
    for m in a:
        _sum+=m.eval(value)
    return _sum

def get_Z(word,active,y):
    a = active.copy()
    sum_arr = np.array([compute_unnorm_marg(y[0],i,word,a,y) for i in range(10)])
    return np.sum(sum_arr)

def compute_marg(t, value, word,active,y):
    a=active.copy()
    return compute_unnorm_marg(t,value,word,a,y)/get_Z(word,a,y)
### To get pairwise log marginals, get messages up to t and s, then add to log pot(t,s)?



alph = {0:'e',1:'t',2:'a',3:'i',4:'n',5:'o',6:'s',7:'h',8:'r',9:'d'}
# def unnorm_p1(x_1):
#     a = active.copy()
#     return compute_msg_update_list(y2,y1,a,train)[x_1]+pf1.eval()[x_1]
# def unnorm_p4(x_4):
#     return compute_msg_update_list(y3,y4,active.copy(),train)[x_4]+pf4.eval()[x_4]
# def unnorm_p2(x_2):
#     a = active.copy()
#     # print(len(a))
#     _sum = 0
#     compute_msg_update_list(y1, y2, a, train)
#     # a.remove(pf1)
#     # a.remove(pf12)
#     # print(len(a))
#     compute_msg_update_list(y4, y3, a, train)
#     # print(len(a))
#     # a.remove(pf2)
#     # a.remove(pf23)
#     compute_msg_update_list(y3, y2, a, train)
#     # a = [p for p in a if y4 not in p.deps]
#     # a.remove(pf3)
#     # a.remove(pf34)
#     # print(len(a))
#     _sum = a[0].eval(x_2) + a[1].eval(x_2) + a[2].eval(x_2)
#     return _sum
#
#
#
#
#
#
# def unnorm_p3(x_3):
#     a = active.copy()
#     # print(len(a))
#     _sum = 0
#     compute_msg_update_list(y1, y2, a, train)
#     # a.remove(pf1)
#     # a.remove(pf12)
#     # print(len(a))
#     compute_msg_update_list(y2,y3,a,train)
#     # print(len(a))
#     # a.remove(pf2)
#     # a.remove(pf23)
#     compute_msg_update_list(y4,y3,a,train)
#     # a = [p for p in a if y4 not in p.deps]
#     # a.remove(pf3)
#     # a.remove(pf34)
#     # print(len(a))
#     _sum= a[0].eval(x_3) + a[1].eval(x_3) + a[2].eval(x_3)
#     return _sum
#
#
# def get_Z():
#     a = active.copy()
#     # print(len(a))
#     _sum = 0
#     compute_msg_update_list(y1, y2, a, train)
#     # a.remove(pf1)
#     # a.remove(pf12)
#     # print(len(a))
#     compute_msg_update_list(y2, y3, a, train)
#     # print(len(a))
#     # a.remove(pf2)
#     # a.remove(pf23)
#     compute_msg_update_list(y4, y3, a, train)
#     # a = [p for p in a if y4 not in p.deps]
#     # a.remove(pf3)
#     # a.remove(pf34)
#     # print(len(a))
#     _sum = [a[0].eval(i) + a[1].eval(i) + a[2].eval(i) for i in range(10)]
#     return logsumexp(_sum)


# for c in range(10):
#     print("PROB: ",alph[c],compute_marg(y[2],c))
    # print("PROB: ",alph[i],unnorm_p3(i))
    # unnorm_p3(i)
with open("../data/test_words.txt") as f:
    realwords = f.read().splitlines()


def build_mrf(idx, type = 'test'):
    y = []
    active=[]
    if type == 'test':
        word = np.genfromtxt("../data/test_img" + str(idx) + ".txt", delimiter=' ')
    if type =='train':
        word = np.genfromtxt("../data/train_img" + str(idx) + ".txt", delimiter=' ')
    for i in range(word.shape[0]):
        y.append(node(type='label', index=i, val=word[i, :]))
        active.append(potential(type='node', deps=[y[i]]))
    for i in range(word.shape[0] - 1):
        active.append(potential(type='edge', deps=[y[i], y[i + 1]]))
    return active, y

# for idx in range(1,6):
#     active = []
#     y=[]
#     word = np.genfromtxt("../data/test_img" + str(idx) + ".txt", delimiter=' ')
#     for i in range(word.shape[0]):
#         y.append(node(type='label', index=i, val=word[i, :]))
#         active.append(potential(type='node', deps=[y[i]]))
#     for i in range(word.shape[0] - 1):
#         active.append(potential(type='edge', deps=[y[i], y[i + 1]]))
#     numcorrect = 0
#     for i in range(word.shape[0]):
#         guess = np.argmax([compute_marg(y[i], c, word,active) for c in range(10)])
#         # print(i)
#         print(alph[guess], ":", realwords[idx-1][i])
#         if alph[guess] == realwords[idx-1][i]:
#             numcorrect+=1
#     print(numcorrect/float(word.shape[0]))


#################################################
train = [np.genfromtxt("/Users/Oliver/Downloads/Assignment2/data/train_img" + str(i+1) + ".txt", delimiter=' ') for i in
         range(50)]
with open('/Users/Oliver/Downloads/Assignment2/data/train_words.txt') as fl:
    train_real = fl.read().splitlines()

grads = np.zeros([10, 321])
count=0
actives = [build_mrf(i+1,type='train') for i in range(50)]
sum_arrs_2 = [[[compute_marg(actives[i][1][j], c, train[i], actives[i][0],actives[i][1]) for j in range(len(train_real[i]))]\
               for c in range(10)] for i in range(50)]
print("DOENE")
for f in range(321):
    for c in range(10):
        _sum1 = 0
        _sum2 = 0
        for i in range(2):
            active, y = actives[i]
            sum_arr1 = [(train_real[i][j] == c) * train[i][j][f] for j in range(len(train_real[i]))]
            _sum1 += np.sum(sum_arr1)
            sum_arr2 = [sum_arrs_2[i][c][j] for j in range(len(train_real[i]))]#[compute_marg(y[j], c, train[i], active) for j in range(len(train_real[i]))]
            _sum2 += np.sum(sum_arr2)
            count+=1.0
            print(count/(321*10*50))
            grads[f, c] = (1 / 50.) * (_sum1 - _sum2)
print(grads)

